**Blockchain Analysis Implementation:**
**Introduction:**
Financial technology has had a profound positive impact on the financial services industry. However, amidst such technological innovation and unbridled growth, fraudsters have been able to identify and exploit gaps. In essence, as technology develops at pace, fraudsters find new ways to cheat the system through adaptive methods. Internal bank fraud is a particularly complex problem to solve, as those who commit this type of fraud do so from a trusted position inside the bank which they work for. Moreover, from the bank’s perspective, they assume that there are sufficient preventative measures in place. 
The issue is, though, the employees entrusted with power over financial systems and databases have a deep understanding of how they can be manipulated. Of the various ways bank employees can commit internal fraud, transaction reversals and account manipulation are the most difficult to detect. Our implementation nullifies both scenarios, utilising an immutable blockchain that records bank employee access attempts as a transaction. 

**Critical discussion:**
Our implementation currently stores users’ data on-chain. Whilst our implementation satisfied certain requirements, such as providing security and audibility of users accessing account details, storing this data on-chain raises considerations. Firstly, the cost of computing and storing data on-chain is relatively higher than off-chain. In addition, as new blocks are mined, the computational complexity required to mine new blocks increases. 
In a proof-of-work system such as ours, the additional amount of compute required to scale the chain to accommodate the bank’s future transaction data may lead to high costs. 
Storing user data on-chain breaks GDPR convention, as users have the right to destroy their data stored on third-party databases upon request. This implementation does not allow for this. If we were to deploy this implementation in a jurisdiction in which GDPR is enforced, we could choose from a couple of different options. First, we may decide to implement hybrid smart contracts (HSCs). These HSCs combine off-chain scalability and privacy with on-chain immutability and tamper resistance.
Another way is through zero-knowledge protocols using a ZK rollup scaling solution. 
In doing so, we would be able to batch multiple transactions together, compute and store them off-chain, but record the occurrence on-chain. This is achieved through complex cryptography that essentially proves statement ‘X’ is true (on-chain data entry) based on statement ‘Y’ (off-chain transaction), without specifically revealing any sensitive information. 
Though, it should be note that is we opted for either of these methods, we would need to integrate either with off-chain oracles or another network, which both present potential security risks and technologically challenging implementations which require interoperability. 
To achieve some level of interoperability, we’ll need to consider connections via servers, APIs, networks, or oracles. These each come with their own benefits and risks. For instance, APIs would allow for easy data migration and large dataset storage in the cloud. However, hackers often target API connections as point of vulnerability, by either accessing API keys, launching DoS attacks, or MITM attacks. Thus, if we were to choose this method, we could utilise an asymmetric cryptography messaging system which encrypts and decrypts data in and out of transit. 
The last, and arguably biggest criticism of our implementation is that there is a single point of failure, as the network’s security is upheld by one node. Aside from immutability, the concept of decentralisation is often seen as a core value proposition of blockchains. In essence, blockchain networks increase decentralisation by increasing the number of nodes in the network, avoiding risks associated with a single point of failure or a malicious node, strengthening the network’s security in hacks, and validating blocks.
**Conclusion:**
In conclusion, I have imported and conducted preliminary checks on data formats and content, to ensure accurate implementation and analysis, generated hash values for various accounts and checked if they matched, utilised functions to create a genesis block and initiate the blockchain. Simulated storing user data access attempts as immutable transaction entries running a simulation that selects random accounts and appends them to the chain, calling create_block function created earlier to add new blocks. 
Finally, modelled latency against number of blocks and found that in low latency networks, average block creation time decreases as the network as more blocks are added, whilst in higher latency networks, the time to create a single block increased as more blocks were added. 
The implementation provides value to banks as an extra security measure against internal bank fraud, as employees cannot reverse transactions or manipulate accounts details. In addition, by adding exemption rules that record failed access attempts in human readable text, we’ve enhanced the audibility of our implementation so that relevant stakeholders can complete the relevant checks. 
Further usability improvements were made in UI, wherein the end user can interact with our network in plain text, via pre-set prompts set by us. Despite our success, we acknowledge that there are inherent limitations. Securing user data in a regulatory-compliant could be a challenge without shifting some computation and/or storage off-chain. However, in moving off-chain, we would need to interact with potential weak points where hackers may strike. Finally, if we are to scale this network, additional nodes would help bolster its security, resilience, and decentralisation.
